       |import std.stdio;
       |import std.conv;
       |import std.array;
       |import std.string;
       |
       |// Enum para representar los resultados de comandos
       |enum ResultCommand {
       |    OK = 0,          // Comando ejecutado sin errores
       |    ERROR = 1,       // Comando inválido o error de sintaxis
       |    END = 2          // Solicitud de salida del programa
       |}
       |
       |// Estados posibles de un bloque en el Buddy System
       |enum State { LIBRE, OCUPADO, DIVIDIDO }
       |
       |// Estructura que representa cada nodo (bloque de memoria)
       |struct Node {
       |    size_t size;       // Tamaño del bloque
       |    State state;       // Estado del bloque
       |    string name;       // Nombre del proceso o reserva
       |    Node* left;        // Hijo izquierdo
       |    Node* right;       // Hijo derecho
       |    Node* parent;      // Referencia al nodo padre
       |}
       |
       |// Crea la raíz del árbol del buddy system
       |Node* crearBuddyTree(size_t size) {
     20|    auto nodo = new Node;
     20|    nodo.size = size;
     20|    nodo.state = State.LIBRE;
     20|    return nodo;
       |}
       |
       |// Divide un nodo en dos nodos hijos (buddies)
       |void subdividir(Node* nodo) {
      9|    if (nodo.size > 1) {
      9|        nodo.state = State.DIVIDIDO;
      9|        nodo.left = crearBuddyTree(nodo.size / 2);
      9|        nodo.right = crearBuddyTree(nodo.size / 2);
      9|        nodo.left.parent = nodo;
      9|        nodo.right.parent = nodo;
       |    }
       |}
       |
       |// Reserva un bloque de memoria del tamaño solicitado
       |bool reservarNodo(Node* node, string name, size_t size){
     20|    if(node is null) return false;
       |
     21|    if(node.size < size) return false;
       |
     24|    if(node.size == size && node.state == State.LIBRE){
      4|        node.name = name;
      4|        node.state = State.OCUPADO;
      4|        return true;
       |    }
       |
     29|    if(node.size > size && node.state == State.LIBRE){
      9|        subdividir(node);
       |        
     18|        if(node.left is null || node.right is null) return false;
       |
      9|        bool reserveLeft = reservarNodo(node.left, name, size);
     18|        if(reserveLeft) return true;
       |
0000000|        return reservarNodo(node.right, name, size);
       |    }
       |
     11|    if (node.size > size && node.state == State.DIVIDIDO) {
      5|        bool reserveLeft = reservarNodo(node.left, name, size);
      9|        if (reserveLeft) return true;
       |
      1|        return reservarNodo(node.right, name, size);
       |    }
       |
      1|    return false;
       |}
       |
       |// Intenta compactar los buddies si ambos están libres
       |void compactar(Node* parent) {
      8|    if (parent is null) return;
       |
      6|    auto left = parent.left;
      6|    auto right = parent.right;
       |
     12|    if (left.state == State.LIBRE && right.state == State.LIBRE) {
       |        // fusionar buddies
      5|        parent.left = null;
      5|        parent.right = null;
      5|        parent.state = State.LIBRE;
       |
       |        // seguir subiendo en el árbol
      5|        compactar(parent.parent);
       |    }
       |}
       |
       |// Libera un nodo específico
       |void liberar(Node* node){
      2|    node.state = State.LIBRE;
      2|    node.name = "";
       |
      2|    compactar(node.parent);
       |}
       |
       |// Libera un bloque buscando por nombre
       |bool liberarNodo(Node* node, string name){
     22|    if(node is null) return false;
       |
     16|    if(node.name == name && node.state == State.OCUPADO){
      2|        liberar(node);
      2|        return true;
       |    }
       |
     12|    bool freeLeft = liberarNodo(node.left, name);
     21|    if (freeLeft) return true;
       |    
      3|    return liberarNodo(node.right, name);
       |}
       |
       |// Calcula la potencia de dos superior más cercana a n
       |size_t proximaPotenciaDeDos(size_t n){
      5|    if( n <= 1 ) return 1;
      5|    size_t p = 1;
     42|    while(p < n){
     37|        p = p * 2;
       |    }
      5|    return p;
       |}
       |
       |// Calcula la potencia de dos inferior más cercana a n
       |size_t anteriorPotenciaDeDos(size_t n){
      1|    size_t power_iter = 2;
      1|    size_t power_buddy;
     10|    while(true){
     10|        power_buddy = power_iter;
     10|        power_iter = power_iter * 2;
     10|        if(power_iter > n){
      1|            break;
       |        }
       |    }
      1|    return power_buddy;
       |}
       |
       |// Muestra visualmente el árbol del buddy system
       |void mostrarBuddyTree(Node* nodo, size_t nivel = 0){
      4|    if (nodo is null) return;
       |    
      4|    if(nodo.state != State.OCUPADO){
      3|        writeln(" ".replicate(nivel * 2), "- Tamano: ", nodo.size, " | Estado: ", nodo.state);
       |    } else{
      1|        writeln(" ".replicate(nivel * 2), "- Tamano: ", nodo.size, " | Estado: ", nodo.state, " | Nombre del espacio: ", nodo.name);
       |    }
       |
      4|    if (nodo.state == State.DIVIDIDO) {
      1|        mostrarBuddyTree(nodo.left, nivel + 1);
      1|        mostrarBuddyTree(nodo.right, nivel + 1);
       |    }
       |}
       |
       |// Validación de sintaxis para comando "reservar"
       |bool validarReservar(string[] entries_arr){
      7|    if(entries_arr.length != 3) return false;
       |    try{    
      5|        int blocks = to!size_t(entries_arr[1]);
       |    } catch(ConvException e){
      1|        return false;
       |    }
       |
      4|    if(strip(entries_arr[2]) == ""){
0000000|        return false;
       |    }
       |
      4|    return true;
       |}
       |
       |// Validación de sintaxis para comando "liberar"
       |bool validarLiberar(string[] entries_arr){
      4|    return entries_arr.length == 2;
       |}
       |
       |// Validación para comandos sin parámetros (mostrar, salir)
       |bool validarMonoCommands(string[] entries_arr){
      5|    return entries_arr.length == 1;
       |}
       |
       |// Procesa la ejecución de un comando según su tipo
       |ResultCommand proccessInput(int option, Node* root, size_t parameter_blocks = 0, string parameter_name = ""){
       |
     10|    switch(option){
      4|        case 1:
       |            // Redondeamos a la próxima potencia de dos
      4|            parameter_blocks = proximaPotenciaDeDos(parameter_blocks);
       |
      4|            if(reservarNodo(root, parameter_name, parameter_blocks)){
      3|                writeln("Memoria reservada con exito.");
      3|                return ResultCommand.OK;
       |            } else {
      1|                writeln("Error: No se pudo reservar la memoria.");
      1|                return ResultCommand.ERROR;
       |            }
       |
      3|        case 2:
      3|            if(liberarNodo(root, parameter_name)){
      2|                writeln("Bloque de memoria liberado con exito.");
      2|                return ResultCommand.OK;
       |            } else{
      1|                writeln("No se consiguió el bloque de memoria");
      1|                return ResultCommand.ERROR;
       |            }
       |
      2|        case 3:
      2|            mostrarBuddyTree(root);
      2|            break;
       |            
      1|        case 4:
      1|            writeln("Saliendo...");
      1|            return ResultCommand.END;
       |
0000000|        default: break; 
       |    }
       |
      2|    return ResultCommand.OK;
       |}
       |
       |// Analiza y valida la entrada del usuario (CLI)
       |ResultCommand procesarComando(Node* root, string entry){
       |
     18|    entry = entry.strip();
     18|    if(entry.length == 0) {
      1|        writeln("No existe dicho comando");
      1|        return ResultCommand.ERROR;
       |    }
       |
     17|    auto entries_arr = entry.split(" ");
     17|    if(entries_arr.length > 3){
      1|        writeln("No existe dicho comando");
      1|        return ResultCommand.ERROR;
       |    }
       |
     16|    switch(toLower(entries_arr[0])){
      6|        case "reservar":
      6|            if(!validarReservar(entries_arr)) {
      2|                writeln("Error: Sintaxis de 'RESERVAR' incorrecta, se esperan dos parámetros.");
      2|                return ResultCommand.ERROR;
       |            }
      4|            return proccessInput(1, root, to!size_t(entries_arr[1]), entries_arr[2]);
       |
      4|        case "liberar":
      4|            if(!validarLiberar(entries_arr)) {
      1|                writeln("Error: Sintaxis de 'LIBERAR' incorrecta, se espera un parámetro.");
      1|                return ResultCommand.ERROR;
       |            }
      3|            return proccessInput(2, root, parameter_name: entries_arr[1]);
       |
      3|        case "mostrar":
      3|            if(!validarMonoCommands(entries_arr)) {
      1|                writeln("Error: Sintaxis de 'MOSTRAR' incorrecta, no se esperan parámetros.");
      1|                return ResultCommand.ERROR;
       |            }
      2|            return proccessInput(3, root);
       |
      2|        case "salir":
      2|            if(!validarMonoCommands(entries_arr)) {
      1|                writeln("Error: Sintaxis de 'SALIR' incorrecta, no se esperan parámetros.");
      1|                return ResultCommand.ERROR;
       |            }
      1|            return proccessInput(4, root);
       |
      1|        default:
      1|            writeln("Error: No existe dicho comando");
      1|            return ResultCommand.ERROR;
       |    }
       |}
       |
       |// Valida los argumentos de inicio del programa
       |ResultCommand memory_validator(string[] args){
       |
      5|    if(args.length < 2 || args.length > 2){
      2|        writeln("Error: Debe enviar la cantidad de bloques");
      2|        return ResultCommand.END;
       |    }
       |
      1|    size_t memory_size;
      1|    string memory_size_txt = args[1];
       |
       |    try{
      1|        memory_size = to!size_t(memory_size_txt);
       |    } catch(ConvException e){   
      1|        writeln("Error: No envió un valor numérico");
      1|        return ResultCommand.END;
       |    }
       |
0000000|    return ResultCommand.OK;
       |}
       |
       |// Función principal
       |void main(string[] args){
       |
0000000|    ResultCommand validate = memory_validator(args);
       |
0000000|    if(validate == ResultCommand.END) return;
       |
0000000|    size_t memory_size = to!size_t(args[1]);
       |
       |    // Redondeamos a la potencia de dos inferior más cercana
0000000|    size_t power_buddy = anteriorPotenciaDeDos(memory_size); 
0000000|    writeln("La memoria disponible para el Buddy System es: ", power_buddy);
       |
0000000|    Node* root = crearBuddyTree(power_buddy);
       |
       |    // Ciclo principal de comandos
0000000|    while(true){
0000000|        write("> ");
0000000|        string entry = readln();
       |
0000000|        int exit = procesarComando(root, entry);
       |
0000000|        if (exit == ResultCommand.END) break;
       |    }
       |}
       |
       |// --------------------- PRUEBAS UNITARIAS ---------------------
       |
       |unittest {
       |    // Validación de entrada de memoria incorrecta
      1|    assert(memory_validator(["programa", "holaaa"]) == ResultCommand.END);
      1|    assert(memory_validator(["programa"]) == ResultCommand.END);
      1|    assert(memory_validator(["programa", "holaaa", "holaa"]) == ResultCommand.END);
       |
      1|    size_t test_memory_size = 1056;
      1|    size_t test_power_buddy = anteriorPotenciaDeDos(test_memory_size);
      1|    assert(test_power_buddy == 1024);
       |
      1|    Node* test_root = crearBuddyTree(test_power_buddy);
       |
       |    // Reservar y liberar
      1|    assert(procesarComando(test_root, "reservar 32 nombre_1") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "reservar 32 nombre_1") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "liberar nombre_1") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "liberar nombre_1") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "liberar nombre_1") == ResultCommand.ERROR);
       |
       |    // Casos con errores de sintaxis
      1|    assert(procesarComando(test_root, "liberar nombre apellido") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "reservar 32 nombre 1") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "reservar 2046 proceso_1") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "reservar treinta proceso_1") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "reservar 25   ") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "mostrar 23") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "buscar 23") == ResultCommand.ERROR);
      1|    assert(procesarComando(test_root, "salir 123") == ResultCommand.ERROR);
       |
       |    // Mostrar árbol y salir
      1|    assert(procesarComando(test_root, "mostrar") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "reservar 502 proceso_1") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "mostrar") == ResultCommand.OK);
      1|    assert(procesarComando(test_root, "salir") == ResultCommand.END);
       |
       |    // Subdivisión al reservar menos de la mitad
      1|    Node* t = crearBuddyTree(64);
      1|    assert(reservarNodo(t, "A", 8) == true);
      1|    assert(t.state == State.DIVIDIDO);
       |
       |    // Redondeo exacto
      1|    assert(proximaPotenciaDeDos(128) == 128);
       |
      1|    writeln("¡Todos los tests pasaron correctamente!");
       |}
BuddySystem.d is 91% covered
