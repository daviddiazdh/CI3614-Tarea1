       |import std.stdio;
       |import std.conv;
       |import std.algorithm;
       |import core.stdc.stdlib : exit;
       |import std.string;
       |import std.array;
       |
       |alias Matrix = double[][];
       |
       |Matrix matrix_transpose_product(Matrix matrix){
      5|    Matrix matrix_product;
      5|    int N = matrix.length;
       |    
       |    // Crear la matriz inicializada con 0's
      5|    matrix_product.length = N;
     39|    foreach(i; 0..N){
      8|        matrix_product[i].length = N;
       |    }
       |
       |    // Iterador filas
     26|    for (int i = 0; i < N; i++){
       |        // Iterador filas nuevamente
     52|        for(int j = 0; j < N; j++){
     18|            double sum = 0;
       |            // Iterador de productos
    124|            for(int k = 0; k < N; k++){
     44|                sum = sum + matrix[i][k] * matrix[j][k];
       |            }
     18|            matrix_product[i][j] = sum;
       |        }
       |    }
      5|    return(matrix_product);
       |}
       |
       |void main(){
       |
0000000|    int n;
0000000|    writeln("Introduce la dimensión n de la matriz (n x n): ");
       |    
       |    try{
0000000|        n = to!int(readln().strip());
       |    } catch(ConvException){
0000000|        writeln("Error: Debe enviar un valor numérico.");
0000000|        return;
       |    }
       |
0000000|    double[][] matrix;
0000000|    matrix.length = n;
       |
0000000|    writeln("Introduce los elementos de la matriz fila por fila:");
0000000|    foreach (i; 0 .. n) {
0000000|        auto line = readln().strip.split();
       |        try{
0000000|            matrix[i] = line.map!(to!double).array;
       |        } catch(ConvException e){
0000000|            writeln("Error: Debe enviar solo valores numéricos");
0000000|            return;
       |        }
       |        
0000000|        if (matrix[i].length != n) {
0000000|            writeln("Error: la fila debe tener exactamente ", n, " valores.");
0000000|            return;
       |        }
       |    }
       |
       |    // Se debe colocar la matriz aquí
0000000|    Matrix matrix_product = matrix_transpose_product(matrix);
0000000|    writeln(matrix_product);
0000000|    exit(0);
       |    
       |}   
       |
       |unittest {
       |
      1|    Matrix m1 = [[1, 2, 4],
       |                 [1, 3, 5],
       |                 [1, 2, 3]];
      1|    Matrix expected1 = [[21, 27, 17],
       |                        [27, 35, 22],
       |                        [17, 22, 14]];
      1|    assert(matrix_transpose_product(m1) == expected1);
       |
      1|    Matrix m2 = [[1, 0],
       |                 [0, 1]];
      1|    Matrix expected2 = [[1, 0],
       |                        [0, 1]];
      1|    assert(matrix_transpose_product(m2) == expected2);
       |
      1|    Matrix m3 = [[2, 2],
       |                 [2, 2]];
      1|    Matrix expected3 = [[8, 8],
       |                        [8, 8]];
      1|    assert(matrix_transpose_product(m3) == expected3);
       |
      1|    Matrix m4 = [[1]];
      1|    Matrix expected4 = [[1]];
      1|    assert(matrix_transpose_product(m4) == expected4);
       |
       |    // Matriz vacía
      1|    Matrix m5 = [];
      1|    assert(matrix_transpose_product(m5).length == 0);
       |
      1|    writeln("¡Todos los tests pasaron correctamente!");
       |}
TMatrixProduct.d is 58% covered
