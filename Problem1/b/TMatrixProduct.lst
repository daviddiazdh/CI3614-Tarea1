       |import std.stdio;
       |import std.conv;
       |import std.algorithm : all;
       |import core.stdc.stdlib : exit;
       |
       |alias Matrix = int[][];
       |
       |Matrix matrix_transpose_product(Matrix matrix){
      5|    Matrix matrix_product;
      5|    int N = matrix.length;
       |
       |    // Verificar que la matriz es cuadrada
     13|    bool matrix_nxn_verification = matrix.all!(x => x.length == N);
      5|    if(!matrix_nxn_verification){
0000000|        writeln("Error: La matriz no es cuadrada.");
0000000|        exit(1);
       |    }
       |
       |    // Crear la matriz inicializada con 0's
      5|    matrix_product.length = N;
     39|    foreach(i; 0..N){
      8|        matrix_product[i].length = N;
       |    }
       |
       |    // Iterador filas
     26|    for (int i = 0; i < N; i++){
       |        // Iterador filas nuevamente
     52|        for(int j = 0; j < N; j++){
     18|            int sum = 0;
       |            // Iterador de productos
    124|            for(int k = 0; k < N; k++){
     44|                sum = sum + matrix[i][k] * matrix[j][k];
       |            }
     18|            matrix_product[i][j] = sum;
       |        }
       |    }
      5|    return(matrix_product);
       |}
       |
       |void main(){
       |
0000000|    Matrix matrix_product = matrix_transpose_product([[1, 2, 4],[1, 3, 5], [1, 2, 3]]);
0000000|    writeln(matrix_product);
0000000|    exit(0);
       |    
       |}   
       |
       |unittest {
       |
       |    // --- Pruebas unitarias ---
      1|    Matrix m1 = [[1, 2, 4],
       |                 [1, 3, 5],
       |                 [1, 2, 3]];
      1|    Matrix expected1 = [[21, 27, 17],
       |                        [27, 35, 22],
       |                        [17, 22, 14]];
      1|    assert(matrix_transpose_product(m1) == expected1);
       |
      1|    Matrix m2 = [[1, 0],
       |                 [0, 1]];
      1|    Matrix expected2 = [[1, 0],
       |                        [0, 1]];
      1|    assert(matrix_transpose_product(m2) == expected2);
       |
      1|    Matrix m3 = [[2, 2],
       |                 [2, 2]];
      1|    Matrix expected3 = [[8, 8],
       |                        [8, 8]];
      1|    assert(matrix_transpose_product(m3) == expected3);
       |
      1|    Matrix m4 = [[1]];
      1|    Matrix expected4 = [[1]];
      1|    assert(matrix_transpose_product(m4) == expected4);
       |
       |    // Matriz vacía
      1|    Matrix m5 = [];
      1|    assert(matrix_transpose_product(m5).length == 0);
       |
       |    // Matriz no cuadrada (debería terminar con exit)
       |    // Nota: no se puede probar directamente con assert porque la función llama a exit(1)
       |    // Pero podemos dejarlo como comentario para indicar el caso.
       |    // Matrix m6 = [[1, 2, 3], [4, 5, 6]];
       |    // matrix_transpose_product(m6); // <-- debería imprimir error y salir.
       |
      1|    writeln("¡Todos los tests pasaron correctamente!");
       |}
TMatrixProduct.d is 85% covered
