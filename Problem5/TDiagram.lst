       |import std.stdio;
       |import std.container;
       |import std.array;
       |import std.string;
       |
       |// Resultado estándar de comandos
       |enum ResultCommand { OK = 0, ERROR = 1, END = 2 }
       |
       |// Nodo del grafo (representa un lenguaje)
       |class Nodo {
       |    string nombre;
       |    Arista[] aristas;
       |
      6|    this(string nombre) {
      6|        this.nombre = nombre;
      6|        this.aristas = [];
       |    }
       |}
       |
       |// Representa una arista entre lenguajes (INTERPRETE o TRADUCTOR)
       |class Arista {
       |    string tipo;
       |    Nodo destino;
       |    Nodo base; // en caso de traductor, se usa lenguaje base
       |
      5|    this(string tipo, Nodo destino, Nodo base = null) {
      5|        this.tipo = tipo;
      5|        this.destino = destino;
      5|        this.base = base;
       |    }
       |}
       |
       |// Diccionarios globales para almacenar los lenguajes y programas
       |Nodo[string] grafo;       
       |string[string] programas;
       |
       |// Normaliza nombres de lenguajes (mayúsculas)
       |string norm(string s) {
     49|    return s.toUpper();
       |}
       |
       |// Crea un nodo si no existe, y lo devuelve
       |Nodo obtenerOCrearNodo(string nombre) {
     13|    auto key = norm(nombre);
     13|    if (!(key in grafo)) {
      3|        grafo[key] = new Nodo(key);
       |    }
     13|    return grafo[key];
       |}
       |
       |// Agrega una relación de intérprete entre lenguajes
       |void agregarInterprete(string lenguaje, string lenguajeBase) {
      2|    auto keyLeng = norm(lenguaje);
      2|    auto keyBase = norm(lenguajeBase);
       |
       |    // Crear los lenguajes si no existen
      2|    if (!(keyLeng in grafo)) definirLenguaje(lenguaje);
      2|    if (!(keyBase in grafo)) definirLenguaje(lenguajeBase);
       |
      2|    auto nodoLenguaje = grafo[keyLeng];
      2|    auto nodoBase = grafo[keyBase];
       |
      2|    nodoLenguaje.aristas ~= new Arista("INTERPRETE", nodoBase);
       |}
       |
       |// Agrega una relación de traductor entre lenguajes
       |void agregarTraductor(string lenguajeOrigen, string lenguajeDestino, string lenguajeBase) {
      3|    auto kOrig = norm(lenguajeOrigen);
      3|    auto kDest = norm(lenguajeDestino);
      3|    auto kBase = norm(lenguajeBase);
       |
       |    // Crear los lenguajes si no existen
      3|    if (!(kOrig in grafo)) definirLenguaje(lenguajeOrigen);
      3|    if (!(kDest in grafo)) definirLenguaje(lenguajeDestino);
      3|    if (!(kBase in grafo)) definirLenguaje(lenguajeBase);
       |
      3|    auto nodoOrigen = grafo[kOrig];
      3|    auto nodoDestino = grafo[kDest];
      3|    auto nodoBase = grafo[kBase];
       |
      3|    nodoOrigen.aristas ~= new Arista("TRADUCTOR", nodoDestino, nodoBase);
       |}
       |
       |// Determina si un lenguaje puede ejecutarse localmente
       |bool puedeEjecutar(Nodo nodo, bool[string]* visitados = null) {
     15|    bool[string] local;
     15|    if (visitados is null)
      6|        visitados = &local;
       |
       |    // Si ya se visitó el nodo, evitar ciclos
     30|    if ((*visitados).get(nodo.nombre, false))
0000000|        return false;
     15|    (*visitados)[nodo.nombre] = true;
       |
       |    // Caso base: si es el lenguaje LOCAL
     15|    if (nodo.nombre == norm("LOCAL"))
      6|        return true;
       |
       |    // Revisar aristas salientes
     34|    foreach (ref arista; nodo.aristas) {
      7|        if (arista.tipo == "INTERPRETE") {
       |            
      5|            if (puedeEjecutar(arista.destino, visitados))
      5|                return true;
      2|        } else if (arista.tipo == "TRADUCTOR") {
       |            
      2|            bool[string] copiaBase = (*visitados).dup;
      2|            bool[string] copiaDestino = (*visitados).dup;
      2|            if (puedeEjecutar(arista.base, &copiaBase) &&
      2|                puedeEjecutar(arista.destino, &copiaDestino))
      2|                return true;
       |        }
       |    }
       |
      2|    return false;
       |}
       |
       |// Crea un nuevo lenguaje en el grafo
       |void definirLenguaje(string nombre) {
      3|    auto key = norm(nombre);
      3|    grafo[key] = new Nodo(key);
       |}
       |
       |// Define un nuevo programa con su lenguaje asociado
       |bool definirPrograma(string nombre, string lenguaje) {
      6|    if (nombre in programas) {
      1|        writeln("Error: El programa ", nombre, " ya está definido.");
      1|        return false;
       |    }
       |
      5|    auto keyLang = norm(lenguaje);
       |
       |    // Crear el lenguaje si no existe
      5|    if (!(keyLang in grafo)) {
      3|        definirLenguaje(keyLang);
       |    }
       |
      5|    programas[nombre] = keyLang;
      5|    return true;
       |}
       |
       |// Comprueba si un programa puede ejecutarse localmente
       |bool programaEjecutable(string nombre) {
      7|    if (!(nombre in programas)) {
      1|        writeln("Error: programa ", nombre, " no definido.");
      1|        return false;
       |    }
       |
      6|    string lenguaje = programas[nombre];
      6|    auto nodo = grafo[lenguaje];
      6|    return puedeEjecutar(nodo);
       |}
       |
       |// Procesa los comandos del usuario
       |ResultCommand procesarLinea(string linea){
     28|    linea = linea.strip();
     28|    if (linea.length == 0)
      2|        return ResultCommand.OK;
       |
     26|    auto partes = linea.split();
     26|    if (partes.length == 0)
0000000|        return ResultCommand.OK;
       |
     26|    string comando = partes[0].toUpper();
       |
     26|    if (comando == "SALIR") {
      1|        writeln("Saliendo...");
      1|        return ResultCommand.END;
       |    }
       |    
     25|    else if (comando == "DEFINIR") {
     15|        if (partes.length < 2) {
      1|            writeln("Uso: DEFINIR <tipo> [args]");
      1|            return ResultCommand.ERROR;
       |        }
       |
     14|        string tipo = partes[1].toUpper();
       |
     14|        switch (tipo) {
      7|            case "PROGRAMA":
      7|                if (partes.length != 4) {
      1|                    writeln("Uso: DEFINIR PROGRAMA <nombre> <lenguaje>");
      1|                    return ResultCommand.ERROR;
       |                }
     12|                return definirPrograma(partes[2], partes[3]) ?  ResultCommand.OK : ResultCommand.ERROR;
       |
      2|            case "INTERPRETE":
      2|                if (partes.length != 4) {
0000000|                    writeln("Uso: DEFINIR INTERPRETE <lenguaje_base> <lenguaje>");
0000000|                    return ResultCommand.ERROR;
       |                }
      2|                string base = partes[2];
      2|                string lenguaje = partes[3];
      2|                obtenerOCrearNodo(base);
      2|                obtenerOCrearNodo(lenguaje);
      2|                agregarInterprete(lenguaje, base);
      2|                return ResultCommand.OK;
       |
      4|            case "TRADUCTOR":
      4|                if (partes.length != 5) {
      1|                    writeln("Uso: DEFINIR TRADUCTOR <lenguaje_base> <lenguaje_origen> <lenguaje_destino>");
      1|                    return ResultCommand.ERROR;
       |                }
      3|                string baseT = partes[2];
      3|                string origen = partes[3];
      3|                string destino = partes[4];
      3|                obtenerOCrearNodo(baseT);
      3|                obtenerOCrearNodo(origen);
      3|                obtenerOCrearNodo(destino);
      3|                agregarTraductor(origen, destino, baseT);
      3|                return ResultCommand.OK;
       |
      1|            default:
      1|                writeln("Tipo desconocido: ", tipo);
      1|                return ResultCommand.ERROR;
       |        }
       |    }
       |    
     10|    else if (comando == "EJECUTABLE") {
      9|        if (partes.length != 2) {
      2|            writeln("Uso: EJECUTABLE <nombre>");
      2|            return ResultCommand.ERROR;
       |        }
       |
      7|        string nombre = partes[1];
      7|        bool resultado = programaEjecutable(nombre);
      7|        if(resultado){
      4|            writeln("El programa ", nombre, " se ejecuto correctamente");
       |        } else {
      3|            writeln("Error: El programa ", nombre, " no se pudo ejecutar correctamente");
      3|            return ResultCommand.ERROR;
       |        }
      4|        return ResultCommand.OK;
       |    }
       |    else {
      1|        writeln("Comando desconocido: ", comando);
      1|        return ResultCommand.ERROR;
       |    }
       |}
       |
       |void main() {
       |    // Se define el lenguaje LOCAL desde el inicio
0000000|    definirLenguaje("LOCAL");
       |
0000000|    string linea;
0000000|    while (true) {
0000000|        write("> ");
0000000|        linea = chomp(readln());
       |
0000000|        ResultCommand result = procesarLinea(linea);
0000000|        if (result == ResultCommand.END) break;
       |    }
       |}
       |
       |unittest {
       |    // Intérprete antes de la existencia de su lenguaje
      1|    assert(procesarLinea("definir interprete local java") == ResultCommand.OK);
       |
       |    // Programa en C sin ruta a LOCAL
      1|    assert(procesarLinea("definir programa c1 c") == ResultCommand.OK);
      1|    assert(procesarLinea("ejecutable c1") == ResultCommand.ERROR);
       |
       |    // Traductor de C en base a JAVA hacia JAVA (permite ejecutar C)
      1|    assert(procesarLinea("definir traductor java c java") == ResultCommand.OK);
      1|    assert(procesarLinea("ejecutable c1") == ResultCommand.OK);
       |
       |    // Programa en Python
      1|    assert(procesarLinea("definir PROGRAMA p1 python") == ResultCommand.OK);
      1|    assert(procesarLinea("definir interprete local PYTHON") == ResultCommand.OK);
      1|    assert(procesarLinea("ejecutable p1") == ResultCommand.OK);
       |
       |    // Programa duplicado
      1|    assert(procesarLinea("definir PROGRAMA p1 C#") == ResultCommand.ERROR);
       |
       |    // Programa inexistente
      1|    assert(procesarLinea("ejecutable j1") == ResultCommand.ERROR);
       |
       |    // Comandos vacíos o con espacios
      1|    assert(procesarLinea("") == ResultCommand.OK);
      1|    assert(procesarLinea("         ") == ResultCommand.OK);
       |
       |    // Sintaxis inválida
      1|    assert(procesarLinea("definir") == ResultCommand.ERROR);
      1|    assert(procesarLinea("definir programa hola") == ResultCommand.ERROR);
      1|    assert(procesarLinea("definir traductor hola python") == ResultCommand.ERROR);
      1|    assert(procesarLinea("definir al_arco") == ResultCommand.ERROR);
      1|    assert(procesarLinea("ejecutable") == ResultCommand.ERROR);
      1|    assert(procesarLinea("ejecutable hola.py gol") == ResultCommand.ERROR);
      1|    assert(procesarLinea("comando_que_no_existe") == ResultCommand.ERROR);
       |
       |    // Cadena de traductores (c → d → local)
      1|    assert(procesarLinea("definir traductor local d local") == ResultCommand.OK);
      1|    assert(procesarLinea("definir traductor local c d") == ResultCommand.OK);
      1|    assert(procesarLinea("definir programa chain_prog c") == ResultCommand.OK);
      1|    assert(procesarLinea("ejecutable chain_prog") == ResultCommand.OK);
       |
       |    // Programa en lenguaje aislado sin intérprete ni traductor
      1|    assert(procesarLinea("definir programa solitario brainfuck") == ResultCommand.OK);
      1|    assert(procesarLinea("ejecutable solitario") == ResultCommand.ERROR);
       |
       |    // Definir un programa que esté en local de una vez
      1|    assert(procesarLinea("definir programa compilable local") == ResultCommand.OK);
      1|    assert(procesarLinea("ejecutable compilable") == ResultCommand.OK);
       |
       |    // Salida
      1|    assert(procesarLinea("salir") == ResultCommand.END);
       |
      1|    writeln("¡Todos los tests pasaron correctamente!");
       |}
TDiagram.d is 93% covered
